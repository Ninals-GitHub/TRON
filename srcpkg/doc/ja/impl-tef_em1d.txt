/*
 *----------------------------------------------------------------------
 *    T-Kernel 2.0 Software Package
 *
 *    Copyright 2011 by Ken Sakamura.
 *    This software is distributed under the T-License 2.0.
 *----------------------------------------------------------------------
 *
 *    Released by T-Engine Forum(http://www.t-engine.org/) at 2011/05/17.
 *
 *----------------------------------------------------------------------
 */

==============================================================================
        tef_em1d実装仕様書
==============================================================================
                                                               Version 1.00.00
1. 概要

本書は、T-Monitor、T-Kernel およびデバイスドライバーに関する T-Engine リファレ
ンスボード(以後 tef_em1d と表記) 固有の実装に関する仕様書である。

2. 全体の実装仕様

2.1 レジスタ名称

      ARM プロセッサのレジスタ名称は、概ね「ARM アーキテクチャリファレンスマニ
      ュアル (ARM DDI 0406)」にしたがうが、特にシステム制御コプロセッサのレジ
      スタは、下記のような形式のレジスタ指定により示す場合がある。

              CPn.CRn.opc1.CRm.opc2

              CPn     コプロセッサ番号
              CRn     コプロセッサレジスタ指定
              CRm     追加のコプロセッサレジスタ指定
              opc1    オペコード１
              opc2    オペコード２

      以下にいくつかの例を挙げる。

      SCTLR   (CP15.c1.0.c0.0)        システム制御レジスタ
      CPACR   (CP15.c1.0.c0.2)        コプロセッサアクセス制御レジスタ
      TTBR0   (CP15.c2.0.c0.0)        変換テーブルベースレジスタ０
      TTBR1   (CP15.c2.0.c0.1)        変換テーブルベースレジスタ１
      TTBCR   (CP15.c2.0.c0.2)        変換テーブルベース制御レジスタ
      PRRR    (CP15.c10.0.c2.0)       一次領域再マップレジスタ
      NMRR    (CP15.c10.0.c2.1)       ノーマルメモリ再マップレジスタ

2.2 プロセッサの設定

  (1) MMU

      MMU は以下の設定とする。
      この設定は、システム起動時に T-Monitor により設定され、以後変更されない
      (変更してはならない)。

   (a) SCTLR.AFE [29] = 1

      ページテーブルのアクセスフラグを有効にする。

   (b) SCTLR.TRE [28] = 1

      メモリー属性 TEX の再マップを有効にする。

   (c) PRRR = 0x000a8aa4

   (d) NMRR = 0x44e048e0

      メモリー属性の再マップを、以下のように割り当てる。

      TEX[0] C B      メモリータイプ  内部キャッシュ  外部キャッシュ
           0 0 0      Strongly-order  None            None
           0 0 1      Device          None            None
           0 1 0      Normal          WT-NA           WT-NA
           0 1 1      Normal          WB-NA           WB-NA
           1 0 0      Normal          None            None
           1 0 1      Normal          WT-NA           WB-A
           1 1 0      (未使用)
           1 1 1      Normal          WB-A            WB-A

              WT-NA   Write-through, no allocate on write
              WB-NA   Write-back, no allocate on write
              WB-A    Write-back, allocate on write

  (2) セキュリティ

      常にセキュア状態で動作するものとし、非セキュア状態は使用しない(非セキュ
      ア状態になることはない)。よって、ARM プロセッサモードのモニターモードも
      使用されない。

      非セキュア状態の各種レジスタの初期設定も特に行わない。

2.3 メモリーマップ

  (1) 全体

          論理アドレス                         モード
           0x00000000 +=======================+       --
                      |タスク固有空間         |       ｜  仮想メモリー (予約)
           0x10000000 +=======================+       --
                      |周辺デバイス           | D RW-
                      |(未使用領域含む)       |
           0x30000000 +-----------------------+
                      |RAM             (64MB) | C RWX
                      |(未使用領域含む)       |
           0x40000000 +-----------------------+
                      |周辺デバイス           | D RW-
                      |(未使用領域含む)       |         物理アドレス
           0x70000000 +-----------------------+       -- 0x00000000
                      |ROM             (32MB) | C R-X ｜  NOR Flash を写像(*1)
           0x72000000 +-----------------------+       -- 0x02000000
                      |(予約)                 |
           0x80000000 +=======================+       --
                      |プログラムマップ用     |       ↑
           0x90000000 +-----------------------+       ｜  仮想メモリー (予約)
                      |メモリーマップ用       |       ↓
           0xa0000000 +=======================+       --
                      |内蔵 SRAM      (128KB) | N RWX
                      |(未使用領域含む)       |
           0xb0000000 +-----------------------+
                      |周辺デバイス           | D RW-
                      |(未使用領域含む)       |
           0xd0000000 +=======================+       --
                      |共有メモリー空間       |       ｜  仮想メモリー (予約)
           0xf0000000 +=======================+       --
                      |内蔵 Boot ROM          | N R--
                      |(未使用領域含む)       |
           0xffffffff +-----------------------+

      モード
        メモリータイプ／キャッシュ属性
          C   キャッシュ ON   Normal memory / Write-back cache, Write allocate
          N   キャッシュ OFF  Normal memory / Non-cacheable
          D   デバイス        Device memory / Non-cacheable

        アクセス属性 ( - はその属性がオフ)
          R   リード可
          W   ライト可
          X   プログラム実行可

      ・仮想メモリーとなっている領域は現在未使用であり、予約されている。
        それ以外の領域は、論理アドレス＝物理アドレスとしてマッピングし、動的に
        変化しない。

           (*1) ただし、タスク固有空間に隠れてしまう NOR Flash の領域は、論理
                アドレス＝物理アドレスとはならず、上記メモリーマップのように移
                動してマッピングする。このマッピングは動的に変化しない。

        本書中のアドレスは、特に記述がない限り論理アドレスで表記されている。

      ・仮想メモリーの領域を除く他の領域は、起動時(初期化時)に T-Monitor によ
        りマッピングを行い、MMU およびキャッシュをイネーブルする。
        未使用の領域および仮想メモリーの領域はマップせず、アクセス不可とする。
        それ以外の領域は、上記の図に示したモードのように設定する。
        これらのマッピングは、セクション(1MB単位)で行う。なお、ドメインはすべ
        て 0 とする。ユーザーレベルからのアクセスはすべて不可とする。

      ・内蔵 SRAM および内蔵 Boot ROM は、システム起動時(ブート時)に使用される
        が、システム起動後は使用されず、OS による管理もされない。
        システム起動後、内蔵 SRAM は、任意の用途に使用可能である。

  (2) ROM 詳細

           0x70000000 +-----------------------+
                      |例外分岐処理           |
                      |T-Monitor              |
           0x70020000 +-----------------------+
                      |ROM 情報               |
           0x70020080 +-----------------------+
                      |(予約)                 |
           0x70030000 +-----------------------+
                      |ROM ディスク           | 初期状態では割り当てなし
           0x70030000 +-----------------------+
                      |T-Kernel               |
                      +-----------------------+
                      |(ユーザーエリア)       |
           0x72000000 +-----------------------+

      ・ROM ディスクの領域は、ROM 情報の設定により変更可能である。

  (3) RAM 詳細

           0x30000000 +-----------------------+
                      |第１レベル             |
                      |ページテーブル         |
           0x30004000 +-----------------------+
                      |例外ベクターテーブル   |
           0x30004400 +-----------------------+
                      |システム共有情報       |
           0x30004440 +-----------------------+
                      |T-Monitor              |
                      |データ／スタック       |
           0x30006000 +-----------------------+ ← RAM_TOP
                      |OS 用                  |
           0x34000000 +-----------------------+ ← RAM_END

      ・システム起動時に T-Monitor により次のように設定され、以後変更されない
        (変更してはならない)。

        VBAR  (CP15.c12.0.c0.0) = 0x70000000  ベクターベースアドレスレジスタ
        TTBR1 (CP15.c2.0.c0.1)  = 0x30000009  変換テーブルベースレジスタ１
        TTBCR (CP15.c2.0.c0.2)  = 0x00000004  変換テーブルベース制御レジスタ

        これらの設定されるレジスタはセキュア状態のレジスタであり、非セキュア状
        態のレジスタは設定されない。また、モニターモードのベクターベースアドレ
        スレジスタである MVBAR(CP15.c12.0.c0.1) も設定されない。

      ・RAM_TOP/RAM_END は T-Monitor が管理し、システム共有情報に設定する。
        RAM_TOP〜RAM_END の間の領域は、OS が管理する。OS はこれらのアドレスを
        システム共有情報から取得する。

2.4 例外ベクターテーブル

                                                 ベクター番号
           0x30004000 +-----------------------+
                      |デフォルトハンドラ     |       0
                      |未定義命令             |       1
                      |プリフェッチアボート   |       2
                      |データアボート         |       3
           0x30004010 +-----------------------+
                      |スーパーバイザ SVC 4   |       4
                      |コール          :      |       |
                      |               SVC 28  |       28
           0x30004074 +-----------------------+
                      |デバッグアボート   命令|       29
                      |                 データ|       30
           0x3000407c +-----------------------+
                      |高速割込       FIQ     |       31
           0x30004080 +-----------------------+
                      |割込           IRQ 0   |       32
                      |                :      |       |
                      |               IRQ 95  |       127
           0x30004200 +-----------------------+
                      |GPIO 割込      port 0  |       128
                      |                :      |       |
                      |               port 127|       255
           0x30004400 +-----------------------+

      ・デフォルトハンドラは、ハンドラが登録されていない例外・割込が発生した場
        合に呼び出されるハンドラ。NULL を未登録とする。
      ・ベクター番号は、tk_def_int() の割込定義番号(dintno)として使用する。
      ・ベクター番号は、SVC 命令の番号(イミディエート値)として使用する。
      ・IRQ 0〜95 は、割込コントローラ(AINT)の INT 0〜95 に対応する。

2.5 ROM 情報

      typedef struct {
              FP      kernel;         /* OS 起動アドレス */
              UB      *sysconf;       /* SYSCONF 先頭 */
              UB      *devconf;       /* DEVCONF 先頭 */
              void    *userarea;      /* RAM ユーザーエリア先頭 */
              FP      userinit;       /* ユーザー初期化プログラムアドレス */
              FP      resetinit;      /* リセット初期化プログラムアドレス */
              VW      rsv[10];        /* 予約 (常に０) */
              UW      rd_type;        /* ROM ディスク種別 */
              UW      rd_blksz;       /* ROM ディスクブロックサイズ */
              UW      rd_saddr;       /* ROM ディスク開始アドレス */
              UW      rd_eaddr;       /* ROM ディスク終了アドレス */
              VW      rsv2[12];       /* 予約 (常に０) */
      } RomInfo;

        kernel        T-Kernel の起動アドレスを指定する。
                      T-Monitor はこのアドレスへジャンプして OS を起動する。
                      T-Kernel を ROM に格納していない場合は NULL を指定する。

        sysconf       SYSCONF を格納した ROM のアドレスを指定する。
                      ROM に格納していない場合は NULL を指定する。

        devconf       DEVCONF を格納した ROM のアドレスを指定する。
                      ROM に格納していない場合は NULL を指定する。

        userarea      RAM の内、OS の管理から外すユーザーエリアの先頭アドレス
                      を指定する。通常は RAM 用予約領域の終端である 0x40000000
                      を指定する。
                      このアドレスと実際に RAM が実装されている領域の終端(上位)
                      アドレスの内のいずれか下位側のアドレスが RAM_END となる。

        userinit      ユーザー作成の初期化プログラムのエントリーアドレスを指定
                      する。
                      OS 起動後、ここへ登録されたプログラムを実行する。
                      NULL を指定した場合は、ユーザー初期化プログラムは実行し
                      ない。
                      一般的にはユーザー初期化プログラムを使用する必要はないた
                      め、NULL を指定する。

        resetinit     ユーザー作成のリセット初期化プログラムのエントリーアドレ
                      スを指定する。
                      リセット処理後、ここへ登録されたプログラムを実行する。
                      NULL を指定した場合は、リセット初期化プログラムは実行し
                      ない。
                      拡張ボードなどのハードウェア初期化処理が OS 起動以前に必
                      要な場合に指定する。

      rd_xxxx では、ROM 上に置かれた ROM ディスクに関する指定を行う。ROM ディ
      スクが存在しないときは、すべて 0 とする。

        rd_type       ディスクタイプ (1 : ROM ディスク (書き込み不可))
        rd_blksz      ディスクブロックサイズ (通常は 512)
        rd_saddr      ROM ディスク領域の開始アドレス
        rd_eaddr      ROM ディスク領域の終了アドレス(+1)

2.6 システム共有情報

      typedef struct {
       (*2)   void    *ramtop;        /* RAM 空き領域先頭 (RAM_TOP) */
       (*2)   void    *ramend;        /* RAM 空き領域終端(+1) (RAM_END) */
              UB      *sysconf;       /* SYSCONF 先頭 */
              UB      *devconf;       /* DEVCONF 先頭 */
              W       taskindp;       /* タスク独立部フラグ */
              UW      taskmode;       /* タスクモードフラグ */
              VW      osrsv[4];       /* OS 使用 */
              VW      rsv[6];         /* 予約 */
      } SysCommonInfo;

      (*2) は、T-Monitor で設定する情報。

        taskindp      T-Kernel/OS によってタスク独立部フラグとして使用される。
                      = 0 : タスク部
                      > 0 : タスク独立部

        taskmode      T-Kernel/OS によってタスクモードフラグとして使用される。

                       31     18 17 16 15      2 1   0
                      +---------+-----+---------+-----+
                      | 予約(0) | PPL | 予約(0) | CPL |
                      +---------+-----+---------+-----+
                      CPL     現在の保護レベル
                      PPL     一つ前の保護レベル

  (1) T-Monitor

      システム起動時およびブート開始時に、システム共有情報を初期化する。

        ramtop,ramend RAM の空き領域の先頭と終端のアドレスを設定する。ramend -
                      ramtop が空き領域のサイズとなる。

      これら以外のシステム共有情報はすべて０クリアする。

  (2) T-Kernel 起動処理

      起動処理の最初に下記のように設定する。

        sysconf   ROM 情報から取得した SYSCONF の先頭アドレス
        devconf   ROM 情報から取得した DEVCONF の先頭アドレス
        ramtop    T-Kernel のデータ領域で消費した領域を除く RAM の先頭アドレス

2.7 システム構成定義(SYSCONF)

      各例外モード用のスタックサイズ(バイト数)を SYSCONF で指定する。
      これらの例外モード用スタックは、通常はハンドラの入り口と出口においてのみ
      使用するため、大きな容量は必要とされない。

                      標準設定値
        AbtStkSz      64              # アボート(MMU)
        UndStkSz      64              # 未定義命令例外
        IrqStkSz      512             # 割込(IRQ)
        FiqStkSz      128             # 高速割込(FIQ)

      これらのスタックは OS によって割り当てられる。スーパーバイザー(SVC)スタ
      ックは、システムスタックとなるため、ここでは指定しない。

      T-Monitor ではこれらのスタックは使用しない。T-Monitor 内の専用スタックを
      使用する。

      T-Monitor は、起動時(初期化時)に各例外モードのスタックポインタ R13 に、
      例外分岐処理で使用される最小限のサイズ(４ワード)分のスタックを設定する。
      これらは、OS が起動するまでの間のみ使用される。

2.8 スーパーバイザーコールの割り当て

      SVC 4           T-Monitor サービスコール                (T-Monitor)
      SVC 5           予備
      SVC 6           T-Kernel システムコール・拡張 SVC       (T-Kernel)
      SVC 7           tk_ret_int() システムコール             (T-Kernel)
      SVC 8           タスクディスパッチャ                    (T-Kernel)
      SVC 9           デバッガサポート機能                    (T-Kernel)
      SVC 10          タスク例外からの復帰                    (T-Kernel)
      SVC 11          プロセス強制終了要求                    (Extension)
      SVC 12〜27      予備

2.9 保護レベル

      保護レベル      プロセッサモード
          0           SVC:スーパーバイザーモード、および USR,SYS 以外のすべて
                      のモード
          1           SYS:システムモード
          2           SYS:システムモード
          3           USR:ユーザーモード

      システムモード(SYS)の時、保護レベル 1〜2 の区別は実質的にはない。
      また、MMU によるメモリー保護は、特権とユーザーの２レベルであるため、保護
      レベル 0〜2 はすべて特権モードとなり、MMU による保護に差異はない。

2.10 スタック

  (1) ユーザースタック／システムスタック

      ユーザーモード(USR)およびシステムモード(SYS)のスタックをユーザースタック
      とし、スーパーバイザーモード(SVC)のスタックをシステムスタックとする。

      ユーザースタック        R13_usr
      システムスタック        R13_svc

  (2) 割込スタック

      ユーザースタック／システムスタックとは別に、タスクと独立した割込スタック
      がある。スーパーバイザーモード(SVC)を除くすべての例外モードのスタックを
      割込スタックとする。これらには、それぞれ独立したスタック領域が割り当てら
      れる。

      割込スタック            R13_abt, R13_und, R13_irq, R13_fiq

2.11 例外・割込ハンドラ

      ベクターテーブルを参照して各々のハンドラへジャンプするための、例外分岐処
      理ルーチンを用意する。高速割込(FIQ)の場合を除き、この分岐ルーチンでは、
      レジスタやスタックに情報を設定してから、各ハンドラへジャンプする。設定さ
      れる内容は、各例外ごとに異なる。ただし、ip (R12) レジスタには、すべての
      例外に共通してベクターテーブルアドレスが設定される。このベクターテーブル
      アドレスによって、発生した例外のベクター番号を知ることができる。

              (ip - 0x30004000) / 4 = ベクター番号

      デフォルトハンドラへジャンプする場合、ip はデフォルトハンドラのベクター
      テーブルアドレスではなく、発生した例外のベクターテーブルアドレスとなる。

      例外ハンドラへは、割込禁止状態のまま(CPSR.I,F,A は例外発生直後の状態のま
      ま)でジャンプする。
      また、BX 命令によりハンドラへジャンプするので、ベクターテーブルへ設定す
      るハンドラアドレスの最下位ビットが 1 の場合は Thumb モードへ切り替わる。
      そうでなければ、ARM モードのままでジャンプする。

      分岐ルーチンでは、分岐処理のためにいくつかのレジスタを使用する。それらの
      レジスタは、下記に示すようにスタックへ保存される。分岐ルーチンでは、これ
      らのレジスタ以外は保存しないので、その他のレジスタは各ハンドラで必要に応
      じて保存する必要がある。また、ハンドラから戻るときには、分岐ルーチンで保
      存したレジスタを含めて復帰する必要がある。

  (1) 高速割込(FIQ)

      FIQ の割込ベクターに設定されたハンドラを無条件に呼び出す。
      要因ごとの独立したベクターはなく、すべて同じハンドラを呼び出す。
      デフォルトハンドラの呼出もない。したがって、FIQ の割込を使用する場合は、
      必ずハンドラを定義しておかなければならない。

      ハンドラ呼出時のレジスタの保存等は一切行われない。
      ハンドラの呼出処理において R12_fiq レジスタを使用するため、R12_fiq レジ
      スタは破壊される。

      ハンドラ呼出時のプロセッサ状態
              CPSR.F = 1      高速割込禁止
              CPSR.I = 1      割込禁止
              CPSR.A = 1      アボート例外禁止
              CPSR.M = 17     FIQ:高速割込モード

  (2) 割込(IRQ)

      割込コントローラ(AINT)の ACPU 割込マスク・ステータス・レジスタ(IT0_MST0,1,
      2)によって取得した割込要因から割込優先度を判定し、最も優先度の高い割込の
      ハンドラへ分岐してハンドラを呼び出す。
      割込優先度は割込要因番号(INT 0〜95)の降順で、INT 95 (IRQ95) が最高優先度、
      INT 0 (IRQ0) が最低優先度となる。
      割込要因がないときは、INT 95 (IRQ95) のハンドラを呼び出す。

      GPIO 割込(下記)の場合は、更に GPIO ポートからの割込要因によって分岐する。

              IRQ26   GIO6 Interrupt (GPIO port  96〜111)
              IRQ27   GIO7 Interrupt (GPIO port 112〜127)
              IRQ50   GIO0 Interrupt (GPIO port   0〜 15)
              IRQ51   GIO1 Interrupt (GPIO port  16〜 31)
              IRQ52   GIO2 Interrupt (GPIO port  32〜 47)
              IRQ53   GIO3 Interrupt (GPIO port  48〜 63)
              IRQ79   GIO4 Interrupt (GPIO port  64〜 79)
              IRQ80   GIO5 Interrupt (GPIO port  80〜 95)

      入力ポート割込マスカブル・ステータス・レジスタ(GIO_MST)によって取得した
      割込要因から割込優先度を判定し、最も優先度の高い割込のハンドラへ分岐して
      ハンドラを呼び出す。
      割込優先度は入力ポート番号(port 0〜127)の降順で、port 127 が最高優先度、
      port 0 が最低優先度となる。GPIO 割込は上記のように、16本ずつのグループに
      分かれているため、各グループ内で優先度判定される。
      割込要因がないときは、IRQ95 のハンドラを呼び出す。
      なお、GPIO の各ポートを割込入力として使用するか否かは、GPIO の設定による。

      ハンドラ呼出時のスタック
              +---------------+
      sp  ->  |R3             |
              |R12=ip         |
              |R14=lr         | <- 割込からの復帰アドレス
              |SPSR           |
              +---------------+

      ハンドラ呼出時のレジスタ
              ip = ベクターテーブルアドレス
              lr, r3 = 不定

      ハンドラ呼出時のプロセッサ状態
              CPSR.F = ?      割り込まれた時の状態のまま
              CPSR.I = 1      割込禁止
              CPSR.A = 1      アボート例外禁止
              CPSR.M = 18     IRQ:割込モード

  (3) その他の例外(SVC,ABT,UND)

      ハンドラ呼出時のスタック
              +---------------+
      sp  ->  |R12=ip         |
              |R14=lr         | <- 復帰アドレス
              |SPSR           |
              +---------------+

      復帰アドレス
      SVC の時        SVC 命令の次の命令への復帰アドレス
      ABT の時        アボートした命令への復帰アドレス
      UND の時        未定義命令の次の命令への復帰アドレス

      ハンドラ呼出時のレジスタ
              ip = ベクターテーブルアドレス
              lr = 不定

      ハンドラ呼出時のプロセッサ状態
              CPSR.F = ?      例外発生時の状態のまま
              CPSR.I = 1      割込禁止
              CPSR.A = ?      SVC,UND: 例外発生時の状態のまま
                       1      ABT: アボート例外禁止
              CPSR.M = 19     SVC:スーパーバイザーモード
                       23     ABT:アボートモード
                       27     UND:未定義命令例外モード

   (a) アボート例外(ABT)

      プリフェッチアボートおよびデータアボートでは、フォルトステータスレジスタ
      (IFSR,DFSR)によりデバッグイベントが示されている場合は、デバッグアボート
      (命令またはデータ)ハンドラを呼び出す。
      それ以外の場合は、プリフェッチアボートまたはデータアボートハンドラを呼び
      出す。

2.12 システムコール

      レジスタの保存規則や引数の受け渡しは、C の関数呼出の形式に準拠する。
      C 言語における、基本的なレジスタの割り当て規則は次の通り。

      R0〜R3, R12=ip  テンポラリレジスタ
      R4〜R10         パーマネントレジスタ
      R11 = fp        フレームポインタ
      R13 = sp        スタックポインタ
      R14 = lr        リンクレジスタ(関数戻りアドレス)
      R15 = pc        プログラムカウンタ

      引数    R0〜R3
      戻り値  R0

      テンポラリレジスタが関数の呼出によって破壊される。それ以外のレジスタは保
      存される。
      スタックは FD(Full Descending) 方式。

      USR:ユーザーモード、SYS:システムモード以外のモードで SVC 命令を実行する
      場合、SVC 命令の実行により R14_svc レジスタが破壊されるので、あらかじめ
      R14_svc を保存しなければならない。
      原則として、次のモードでのみ SVC 命令を使用できる。

              USR:ユーザーモード
              SYS:システムモード
              SVC:スーパーバイザーモード

      このとき、SVC 命令は次のように実行する必要がある。

              stmfd   sp!, {lr}
              svc     #
              ldmfd   sp!, {lr}

      USR, SYS モードでは、lr の保存は必ずしも必要ないが、モードに関係なく同じ
      手順で呼び出すために、上記の手順を標準とする。

      USR, SYS, SVC モード以外で SVC 命令を使用する場合は、何らかの方法で
      R14_svc を保存する必要がある。

  (1) T-Monitor サービスコール

      R12=ip  機能コード
      R0      第１引数
      R1      第２引数
      R2      第３引数
      R3      第４引数
      SVC 4
      R0      戻り値

      引数の最大数は４となる。
      上記のようにレジスタに引数と機能コードを設定して、SVC 4 により呼び出す。

  (2) T-Kernel システムコール

      R12=ip  機能コード (＜0)
      R0      第１引数
      R1      第２引数
      R2      第３引数
      R3      第４引数
      R4      第５引数以降が格納された領域へのポインタ
              第５引数以降はスタック
                      +---------------+
                R4 -> |第５引数       |
                      +---------------+
      SVC 6
      R0      戻り値

      第４引数まではレジスタに設定し、第５引数以降はスタックに積んで、SVC 6 に
      より呼び出す。
      T-Kernel/DS のシステムコールも同様だが、SVC 9 を使用する。

  (3) 拡張 SVC

      R12=ip  機能コード (≧0)
      R0      引数パケットへのポインタ
      SVC 6
      R0      戻り値

      引数はすべてパケット化し、パケットの先頭アドレスを R0 レジスタに設定して、
      SVC 6 により呼び出す。
      パケットは通常スタックに作成するが、他の場所でもよい。引数はパケット化す
      るため、数や型に制限はない。

2.13 ブート

      起動は次の手順で行う。

      1.T-Monitor が、ハードウエアの初期化を行う。
      2.T-Monitor が、例外ベクターテーブルおよびシステム共有情報を初期化する。
      3.T-Monitor が ROM 情報の kernel に指定された OS 起動アドレスへジャンプ
        して制御を移し、システムを起動する。

  (1) T-Monitor のブート処理

   (a) 例外ベクターテーブルの設定

      以下のベクターを T-Monitor 自身が処理するように設定する。これら以外は、
      デフォルトハンドラが起動されるように NULL に設定する。

      ベクター番号
            0         デフォルトハンドラ
            4         T-Monitor サービスコール        (SVC 4)
           29         デバッグアボート (命令)
           30         デバッグアボート (データ)
          136         アボートスイッチ (SW1)          (GPIO port 8)

           58         GIO6: GPIO 割込分岐処理         (IRQ26)
           59         GIO7: GPIO 割込分岐処理         (IRQ27)
           82         GIO0: GPIO 割込分岐処理         (IRQ50)
           83         GIO1: GPIO 割込分岐処理         (IRQ51)
           84         GIO2: GPIO 割込分岐処理         (IRQ52)
           85         GIO3: GPIO 割込分岐処理         (IRQ53)
          111         GIO4: GPIO 割込分岐処理         (IRQ79)
          112         GIO5: GPIO 割込分岐処理         (IRQ80)

      デフォルトハンドラは、例外情報を表示したあと、T-Monitor のプロンプトを表
      示してコマンド入力状態とする。

   (b) OS の起動

      ROM 情報の kernel に格納された OS 起動アドレスを参照し、そのアドレスが
      NULL でなければ、そのアドレスへジャンプすることで OS を起動する。
      OS 起動アドレスが NULL であれば ROM 起動は行われず、T-Monitor のコマンド
      入力待ち状態となる。

      OS へ制御を移すときの CPU の状態は次の通りで、T-Monitor サービスコールを
      使用できる状態とする。

              CPSR.I = 1      割込禁止
              CPSR.F = 1      高速割込禁止
              CPSR.A = 0      アボート例外許可
              CPSR.T = 0      ARM モード
              CPSR.M = 19     SVC:スーパーバイザーモード
              R13_svc (sp)    モニタスタック
              R0              0 (ROM 起動であることを示す)
              その他の汎用レジスタは不定

              キャッシュメモリー
              ・キャッシュはオフ (SCTLR.C=0, I=0, Z=0)
              ・キャッシュの内容はすべて無効状態

      スタックポインタ R13_svc (sp) は、T-Monitor のスタック領域(モニタスタック)
      を指している。OS 起動処理中このモニタスタックが使用される。sp がモニタス
      タックを指した状態で、T-Monitor サービスコールが呼び出される。
      なお、OS 起動処理によって使用されるモニタスタックは 2KB 以内とする。

2.14 ユーザー初期化プログラム

      ユーザー初期化プログラムは、ユーザー作成のプログラムなどを起動／終了する
      ための ROM に置かれたユーザー定義のルーチンである。ユーザー初期化プログ
      ラムは、初期起動タスクから次の形式で呼び出される。

              INT  userinit( INT ac, UB **av )

              ac      = 0     起動時呼出
                      = -1    終了時呼出

              戻値    1       usermain を起動
                      0       システム終了(電源オフ)
                      -1      リセット(再起動)

      システム起動時に ac = 0 で呼び出され、システム終了時に ac = -1 で呼び
      出される。終了時の呼出(ac = -1)では、戻値は無視される。
      処理の概略は次のようになる。

                fin = userinit(0, NULL);
                if ( fin > 0 ){
                        fin = usermain();
                }
                userinit(-1, NULL);

      ユーザー初期化プログラムは、初期起動タスクのコンテキストで実行される。
      タスク優先度は 138 である。また、ユーザー初期化プログラムでのスタックの
      消費は 4KB 以内とする。

      ユーザープログラムの起動処理を行った後は、２種類の選択がある。
        (A) ユーザープログラムが終了するまで待った後、userinit() からリターン
            する。
        (B) ユーザープログラムの終了を待たずに userinit() からリターンする。

      いずれの場合も、userinit() からの戻り値によって、その後の処理を選択できる。

2.15 リセット初期化プログラム

      リセット初期化プログラムは、拡張ボードなどのハードウェアの初期化処理を、
      リセット直後に行うための ROM に置かれたユーザー定義のルーチンである。リ
      セット初期化プログラムは、T-Monitor のリセット処理の最後に次の形式で呼び
      出される。

              void resetinit( void )

      リセット初期化プログラムでのスタックの消費は 2KB 以内とする。

2.16 例外・割込ハンドラのエントリールーチン

      ソースプログラム中の以下のファイルを参照のこと。

              monitor/hwdepend/tef_em1d/src/eitent.S
              include/tk/sysdepend/tef_em1d/sysdef_depend.h
              include/tk/sysdepend/tef_em1d/asm_depend.h

3. T-Monitor 実装仕様

3.1 Register コマンド

      Register コマンドでは、以下のレジスタに対応する。

   (a) 汎用レジスタ (G)

      R0, R1, R2, R3, R4, R5, R6, R7,
      R8, R9, R10/SL, R11/FP, R12/IP, R13/SP, R14/LR, R15/PC
      R8_USR, R9_USR, R10_USR, R11_USR, R12_USR, R13_USR, R14_USR
      R8_FIQ, R9_FIQ, R10_FIQ, R11_FIQ, R12_FIQ, R13_FIQ, R14_FIQ
      R13_IRQ, R14_IRQ
      R13_SVC, R14_SVC
      R13_ABT, R14_ABT
      R13_UND, R14_UND

      ※モニタモード用レジスタ(R13_MON, R14_MON)への対応は行わない

   (b) 制御/システムレジスタ (C)

      CPSR, SPSR
      SPSR_FIQ, SPSR_IRQ, SPSR_SVC, SPSR_ABT, SPSR_UND
      SCTLR, TTBR0, TTBR1, TTBCR, DACR, DFSR, IFSR, DFAR, IFAR, CTXIDR

              ※以下のシステム制御コプロセッサレジスタ (CP15.CRn.opc1.CRm.opc2)
                に対応する。

              SCTLR   (CP15.c1.0.c0.0)        システム制御レジスタ
              TTBR0   (CP15.c2.0.c0.0)        変換テーブルベースレジスタ０
              TTBR1   (CP15.c2.0.c0.1)        変換テーブルベースレジスタ１
              TTBCR   (CP15.c2.0.c0.2)        変換テーブルベース制御レジスタ
              DACR    (CP15.c3.0.c0.0)        ドメインアクセス制御レジスタ
              DFSR    (CP15.c5.0.c0.0)        データフォルトステータスレジスタ
              IFSR    (CP15.c5.0.c0.1)        命令フォルトステータスレジスタ
              DFAR    (CP15.c6.0.c0.0)        データフォルトアドレスレジスタ
              IFAR    (CP15.c6.0.c0.2)        命令フォルトアドレスレジスタ
              CTXIDR  (CP15.c13.0.c0.1)       コンテキスト ID レジスタ

      ※モニタモード用レジスタ(SPSR_MON)への対応は行わない

3.2 Break Point コマンド

      以下のブレーク属性に対応する。

      S :     ソフトウェアブレークポイント
              <ブレークアドレス>の命令を実行する直前にブレーク。

    ・ソフトウェアブレークポイントは最大 8 点まで
    ・奇数アドレスへのブレークポイント設定は Thumb 命令とみなす。なお、Thumb-2
      命令への対応は行わない。
    ・ICE を接続した場合は、ブレークポイントの動作は保証しない

3.3 Trace(Step/Next) コマンド

      トレース実行中はすべてのブレークポイントは無効となる。
      トレース実行中に SVC 命令があった場合は、SVC 先はトレースしない。
      次に実行する命令の逆アセンブルは行わず、メモリ内容のダンプを表示する。

3.4 Back Trace, Disassemble コマンド

      対応しない。

3.5 Disk コマンド

      ディスクデバイスには対応しないため、使用できない。

3.6 Kill コマンド

      モニタを終了して、SVC 11 を実行する。
      SVC 11 のハンドラが設定されていないときは何もしない。

    ・SVC 11 は T-Kernel Extension で使用 (ハンドラを設定) することを前提とし
      ている。

3.7 WriteROM コマンド

      以下の WriteROM コマンドにより、RAM 上の内容を NOR Flash ROM に書き込む
      ことができる。

      WriteROM(WROM) rom_addr, data_ram_addr, block_count : Write Flash ROM
      blocks
              rom_addr      : 0x70000000 - 0x71FE0000
              data_ram_addr : 0x30020000 - 0x33FE0000
              block_count   : 1 - 0x100 (1 block = 128KB)

    ・書き込みは、128 KB ブロック単位で行い、Flash ROM アドレスは 128 KB 境界
      でなくてはいけない。
    ・T-Monitor 領域(0x70000000 〜 0x7001FFFF)を指定すると、確認のメッセージを
      表示し、書き換え後はリセット起動となる。

3.8 FlashLoad コマンド

      以下の FlashLoad コマンドにより、S-Format データをロードして、NOR Flash
      ROM に書き込むことができる。

      FlashLoad(FLLO) [attr] : Load S-Format Data & Write Flash ROM
              attr: X  Use XMODEM protocol
                    E  Fill write blocks with 0xFF
                       Default : Overwrite original Flash ROM Image

    ・X を指定した場合、S-Format データのロードは、XMODEM プロトコルで行い、指
      定しない場合は、無手順で行う。
    ・E を指定した場合、128 KB ブロック内のロードしなかった部分には、0xFF が書
      き込まれ、指定しない場合は、もとの内容のままとなる。

3.9 DIP スイッチ

                                              OFF             ON
      --------------------------------------------------------------------
      SW-1    BOOTSEL0                        OFF             -
      SW-2    BOOTSEL1                        OFF             -
      SW-3    BOOTSEL2                        OFF             -
      SW-4    起動選択                        自動ブート      モニタ起動

      SW-4 は、OFF で自動ブート (OS 起動)、 ON でブートせずにモニタ起動となる。

      他のスイッチの設定は、上記の設定に従うこと。

3.10 起動対象となるデバイスの検索順序

      DIP スイッチの SW-4 が ON の状態で起動した場合は、T-Monitor を起動する。
      SW-4 が OFF の場合は、ROM上のプログラム (RomInfo.kernel) が設定されてい
      る場合はこれを起動する。設定されていない場合は T-Monitor を起動する。

3.11 コンソール

      T-Monitor のコンソールとして使用するシリアルポートは、UART0 を使用する。
      通信仕様は以下の通りとする。

              通信速度        115,200 bps
              データ長        8 bit
              ストップビット  1 bit
              パリティ        なし
              フロー制御      XON/XOFF

3.12 T-Monitor のサービスコール

      レジスタの保存規則や引数の受け渡しは、C の関数呼び出し形式に準拠する。引
      数の最大数は 4 となる。

      R12/IP に機能コードを設定して SVC 4 により T-Monitor のサービスコールを
      呼び出す。

      サービスコールの実行中は全ての割り込みはマスクされる。また、スタックは T
      -Monitor 内の専用スタック領域を使用する。

      R12/IP  機能コード
      R0      第１引数
      R1      第２引数
      R2      第３引数
      R3      第４引数
      SVC     4
      R0      戻り値

      機能コード
      0       Enter T-Monitor         モニタへ入る
      1       Get Character           コンソールから 1 文字入力
      2       Put Character           コンソールへ 1 文字出力
      3       Get Line                コンソールから 1 行入力
      4       Put String              コンソールへ文字列出力
      5       Execute Command         モニタコマンドの実行
      6                               (予約)
      7                               (予約)
      8                               (予約)
      9       System Exit             システム終了
      255     Extension SVC           拡張サービス機能

3.13 T-Monitor の拡張サービスコール

      tm_extsvc(INT fno, INT p1, INT p2, INT p3)

      fno                     機能
      -----------------------------------------------------------------
      0x00    デバッグポートの通信速度の取り出し
              p1〜p3:         未使用
              リターン値:     115200

      0x01    ROM ディスク情報の取り出し
              p1:             ROM ディスク情報ポインタを格納する領域
              p2〜p3:         未使用
              リターン値:     0: OK, < 0: エラー

              p1 には、以下の ROM 上のアドレスが格納される。

              p1 -->  UW      rd_type;   /* ROM ディスク種別 */
                      UW      rd_blksz;  /* ROM ディスクブロックサイズ */
                      UW      rd_saddr;  /* ROM ディスク開始アドレス */
                      UW      rd_eaddr;  /* ROM ディスク終了アドレス */

      0x04    (予約)

      0x10    DIP SW 状態の取り出し
              p1〜p3:         未使用
              リターン値:     bit 0〜4  : 不定
                              bit 5     : SW-4 起動選択   (0:OFF 1:ON)
                              bit 6〜31 : 不定

      0x11    (予約)

      0x20    NOR Flash ROM への書き込み
              p1:             Flash ROM アドレス(書き込み先)
                              0x7###0000, ### = 000 - 1FE
              p2:             RAM アドレス(書き込みデータ)
                              0x3###0000, ### = 002 - 3FE
              p3:             書き込みブロック数 (1ブロック = 128 KB)
                              0x01 〜 0x100
              リターン値:     0: OK、< 0 エラー

              ・書き込みは、128 KB ブロック単位で行い、Flash ROM アドレスは
                128 KB 境界でなくてはいけない。
              ・T-Monitor 領域(0x70000000 〜 0x7001FFFF)を指定すると、確認のメ
                ッセージを表示し、書き換え後はリセット起動となる。

3.14 各種クロックの初期化

      T-Monitor は起動時に、以下の EM1-D512 の ASMU レジスタを設定する。

              レジスタ                設定値
              AUTO_FRQ_CHANGE         0x00000000
              PLL1CTRL0               0x00000079
              PLL1CTRL1               0x00000000
              PLL2CTRL0               0x00000061
              PLL2CTRL1               0x00000000
              CLK_MODE_SEL            0x00000001
              NORMALA_DIV             0x00244200
              DIVU70SCLK              0x00000000
              DIVU71SCLK              0x00000000
              DIVU72SCLK              0x00000000
              DIVLCDLCLK              0x00000004
              DIVIICSCLK              0x00530053
              DIVTIMTIN               0x00000003
              DIVSP0SCLK              0x00000074
              TI0TIN_SEL              0x00000000
              TI1TIN_SEL              0x00000000
              TI2TIN_SEL              0x00000000
              TI3TIN_SEL              0x00000000
              TIGnTIN_SEL             0x00000000
              AHBCLKCTRL0             0x00000000
              AHBCLKCTRL1             0x00000000
              APBCLKCTRL0             0x00000000
              APBCLKCTRL1             0x00000000
              CLKCTRL                 0x00000000
              GCLKCTRL0ENA            0xffffffff (GCLKCTRL0 設定後は 0x00000000)
              GCLKCTRL0               0xffffffff
              GCLKCTRL1ENA            0xffffffff (GCLKCTRL1 設定後は 0x00000000)
              GCLKCTRL1               0xffffffff
              GCLKCTRL2ENA            0xffffffff (GCLKCTRL2 設定後は 0x00000000)
              GCLKCTRL2               0xffffffff
              GCLKCTRL3ENA            0xffffffff (GCLKCTRL3 設定後は 0x00000000)
              GCLKCTRL3               0xffffffff
              RESETREQ0ENA            0xffffffff (RESETREQ0 設定後は 0x00000000)
              RESETREQ0               0xffffffe7
              RESETREQ1ENA            0xffffffff (RESETREQ1 設定後は 0x00000000)
              RESETREQ1               0xffffffff
              RESETREQ2ENA            0xffffffff (RESETREQ2 設定後は 0x00000000)
              RESETREQ2               0xffffffff
              RESETREQ3ENA            0xffffffff (RESETREQ3 設定後は 0x00000000)
              RESETREQ3               0xffffffff

      これらの設定値により、各種クロックは以下の値となる。全てのモジュールに対
      してクロックを供給し、DSP 以外の全モジュールのリセットを解除する。

              PLL1: 499.712MHz
                  ACPU:       PLL1/1          499.712MHz
                  ADSP:       PLL1/1          499.712MHz
                  HBUS:       PLL1/3          166.571MHz
                  LBUS:       PLL1/6          83.285MHz
                  FLASH:      PLL1/6          83.285MHz
                  MEMC:       PLL1/3          166.571MHz

              PLL2: 401.408MHz
                  LCD_LCLK:   PLL2/16         25.088MHz

              PLL3: 229.376MHz
                  U70_SCLK:   PLL3/1          229.376MHz
                  U71_SCLK:   PLL3/1          229.376MHz
                  U72_SCLK:   PLL3/1          229.376MHz
                  Txx_TIN:    PLL3/8          28.672MHz
                  IIC_SCLK:   PLL3/48         4.779MHz
                  SP0_SCLK:   PLL3/128        1.792MHz

      クロックモードは常に Normal Mode A で動作し、他のモードへの対応は行わな
      い。周波数自動切換機能は使用せず、この機能には対応しない。

      デバイスドライバ等は必要に応じ、モジュール電源およびリセットの操作、モジ
      ュールの使用するクロックの分周比およびクロックゲートの設定を行う必要があ
      る。

3.15 ピンマルチプレクサの初期化

      T-Monitor は起動時に、以下の EM1-D512 のピンマルチプレクサを設定する。

              レジスタ                設定値
              CHG_L1_HOLD             0x00000000
              CHG_CTRL_AB0_BOOT       0x00000001
              CHG_PINSEL_G0           0x55400C00
              CHG_PINSEL_G16          0x55555555
              CHG_PINSEL_G32          0x54555055
              CHG_PINSEL_G48          0x55555555
              CHG_PINSEL_G64          0xffc05555
              CHG_PINSEL_G80          0x06556940
              CHG_PINSEL_G96          0x55555555
              CHG_PINSEL_G112         0x00000555
              CHG_PINSEL_SP0          0x00000000
              CHG_PINSEL_DTV          0x00000001
              CHG_PINSEL_SD0          0x00000000
              CHG_PINSEL_SD1          0x00000002
              CHG_PINSEL_IIC2         0x00000000
              CHG_PULL_G0             0x55055005
              CHG_PULL_G8             0x00000005
              CHG_PULL_G16            0x00000000
              CHG_PULL_G24            0x00000000
              CHG_PULL_G32            0x00550000
              CHG_PULL_G40            0x00050000
              CHG_PULL_G48            0x11111111
              CHG_PULL_G56            0x11111111
              CHG_PULL_G64            0x11111111
              CHG_PULL_G72            0x00000005
              CHG_PULL_G80            0x00400050
              CHG_PULL_G88            0x55000444
              CHG_PULL_G96            0x44444444
              CHG_PULL_G104           0x04044444
              CHG_PULL_G112           0x00000000
              CHG_PULL_G120           0x00000000
              CHG_PULL0               0x50000004
              CHG_PULL1               0x15110600
              CHG_PULL2               0x60000661
              CHG_PULL3               0x00000000
              GIO_E0_L                0x000001d9
              GIO_E1_L                0x00000604
              GIO_E0_H                0x00001030
              GIO_E1_H                0x00000000
              GIO_E0_HH               0xc0020100
              GIO_E1_HH               0x00040200
              GIO_OL_L                0x06040000
              GIO_OL_HH               0x02000000
              GIO_OH_HH               0x00040000

      これらにより、以下のモジュールに対応したピン設定となる。

              AB0(AsyncBus0)
              LCD
              SD0
              PM0
              UART0, UART1
              IIC
              USB
              GPIO
                      P0      In              DA9052(nIRQ)
                      P2      Out/0           ML7037(/PDN)
                      P3      In              microSD(CD)
                      P4      In              Push-SW(SW4)
                      P6      In              Push-SW(SW3)
                      P7      In              Push-SW(SW2)
                      P8      In              Push-SW(SW1)
                      P9      Out/0           ML7037(PDN)
                      P10     Out/0           カメラモジュール(STBY)
                      P36     In              MKY36(/INT0)
                      P37     In              MKY36(/INT1)
                      P44     In              LAN9221(IRQ)
                      P72     In              MAX7324(/INT)
                      P73     Out/0           LM4876(/SHUTDOWN)
                      P81     In              LAN9221(PME)
                      P82     Out/0           LCD
                      P94     In              RTC(/TIRQ)
                      P95     In              RTC(/AIRQ)

3.16 LED の操作およびディップスイッチ状態の取得

      LED5〜8 の操作およびディップスイッチ SW-4 の状態を取得には、IIC2 および
      これに接続したポートエキスパンダ (MAX7324) を使用する。

      ポートエキスパンダには LED の他にフォトカプラが接続されているが、こちら
      は T-Monitor の操作対象とはしない。

4. T-Kernel 実装仕様

4.1 Thumb 命令セットの使用

      Thumb 命令セットを使用する場合は、「ARM / Thumb Interworking」にしたがっ
      てプログラムされている必要がある。
      C 言語の場合は、コンパイル時に -mthumb-interwork -mthumb オプションを指
      定する。

      タスクやハンドラとして Thumb 命令セットで書かれたものを指定する場合、そ
      のアドレスの最下位ビットに 1 を設定する。ARM 命令セットの場合は 0 を設定
      する。これは、通常リンカが自動的に行うため、プログラマは特に意識する必要
      はない。

4.2 システム状態判定

  (1) タスク独立部 (例外・割込ハンドラ・タイムイベントハンドラ)

      システム共有情報(SysCommonInfo)内のフラグ taskindp を使用して判定する。

      taskindp = 0    タスク部
      taskindp > 0    タスク独立部

      このフラグの設定は、T-Kernel/OS によって行われる。

  (2) 準タスク部 (拡張 SVC ハンドラ)

      T-Kernel/OS 内にソフトウエア的なフラグを設けて判定する。

4.3 T-Kernel/OS で使用する例外・割込

      スーパーバイザーコール (SVC 命令)
      ・T-Kernel システムコール・拡張 SVC     SVC 6
      ・tk_ret_int() システムコール           SVC 7
      ・タスクディスパッチャ                  SVC 8
      ・デバッガサポート機能                  SVC 9
      ・タスク例外からの復帰                  SVC 10

      割込
      ・TI0 タイマー割込                      IRQ 54

4.4 システムコール

      呼び出し側は、C 言語の関数の呼び出し形式で、インターフェースライブラリを
      呼び出す。インターフェースライブラリは、下記のようになる。

      システムコールの呼出は、次のモードからのみ可能である。

              USR:ユーザーモード
              SYS:システムモード
              SVC:スーパーバイザーモード

      これら以外のモードからシステムコールを呼び出す場合は、SVC モードに切り替
      えてから呼び出すか、R14_svc を保存してから呼び出す(システムコールから戻
      ったあとに R14_svc を元の値に復帰する)必要がある。
      なお、USR モードおよび SYS モードに切り替えてはいけない。

      アセンブリ言語のプログラムから呼び出す場合も、C 言語と同様に関数形式によ
      りインターフェースライブラリを経由して呼び出すこととするが、下記のインタ
      ーフェースライブラリ相当のことを行い、直接 SVC 命令で呼び出してもよい。
      レジスタの保存規則は C 言語の規則にしたがうので、アセンブリ言語のプログ
      ラムから呼び出す場合も、C 言語の規則にしたがってレジスタの保存を行う必要
      がある。

  (1) T-Kernel/OS システムコール

      ER tk_xxx_yyy(p1, p2, p3, p4, p5)

      引数は整数またはポインタで、C 言語の関数の引数渡しと同じ形式。

              //      r0 =    p1
              //      r1 =    p2
              //      r2 =    p3
              //      r3 =    p4
              //      +---------------+
              // sp ->|       p5      |
              //      |       :       |
              //      +---------------+
      tk_xxx_yyy:
              stmfd   sp!, {r4}       // r4 保存
              add     r4, sp, #4      // r4 = スタック上のパラメータの位置
              stmfd   sp!, {lr}       // lr 保存
              ldr     ip, =機能コード
              svc     6
              ldmfd   sp!, {lr}       // lr 復帰
              ldmfd   sp!, {r4}       // r4 復帰
              bx      lr

  (2) 拡張 SVC

      INT zxxx_yyy( .... )

      引数は呼出側でパケット化し、パケットの先頭アドレスを R0 レジスタに設定す
      る。

      zxxx_yyy:
              stmfd   sp!, {r0-r3}    // レジスタ上の引数をスタックに積みパケ
      ット化
              mov     r0, sp          // R0 = 引数パケットのアドレス
              stmfd   sp!, {lr}       // lr 保存
              ldr     ip, =機能コード
              svc     6
              ldmfd   sp!, {lr}       // lr 復帰
              add     sp, sp, #4*4    // スタックに積んだ引数を捨てる
              bx      lr

      ここに示した引数のパケット化の方法は例である。引数の数や型によって適切に
      パケット化する必要がある。

  (3) T-Kernel/DS サービスコール

      ER td_xxx_yyy(p1, p2, p3, p4)

      引数は４個以下の整数またはポインタで、C 言語の関数の引数渡しと同じ形式。

              //      r0 =    p1
              //      r1 =    p2
              //      r2 =    p3
              //      r3 =    p4
      td_xxx_yyy:
              stmfd   sp!, {lr}       // lr 保存
              ldr     ip, =機能コード
              svc     9
              ldmfd   sp!, {lr}       // lr 復帰
              bx      lr

4.5 例外・割込ハンドラ

      ER tk_def_int( UINT dintno, T_DINT *pk_dint )

      typedef struct t_dint {
              ATR     intatr;         /* 割込ハンドラ属性 */
              FP      inthdr;         /* 割込ハンドラアドレス */
      } T_DINT;

      dintno には、ベクターテーブルのインデックス番号(0〜255)を指定する。

      FIQ 高速割込は他の例外・割込とは異なる特殊な扱いとなる。後述の FIQ 高速
      割込の説明を参照のこと。

      T-Kernel/OS では割込コントローラに対する処理は何も行わない。割込のクリア
      等は、割込ハンドラが処理しなければならない。

      多重割込を許可する場合、割込コントローラ(または GPIO コントローラ)の割込
      マスクレジスタを操作して、多重割込を許可する割込以外を禁止するように設定
      しなければならない。特に、自身の割込が再入しないようにする必要がある。
      割込コントローラ(または GPIO コントローラ)の割込マスクを変更した場合は、
      割込ハンドラから戻る前に元に戻す必要がある。

      例外・割込ハンドラは、発生した例外・割込の種類に応じて、以下のプロセッサ
      モードの内のいずれかとなる。

              SVC:スーパーバイザーモード
              ABT:アボートモード
              UND:未定義命令例外モード
              IRQ:割込モード
              FIQ:高速割込モード

      ただし、TA_HLNG が指定されたハンドラの場合、高級言語対応ルーチンによって
      SVC モードへ自動的に変更される。したがって、どのタイプの例外・割込が発生
      しても、TA_HLNG 指定の場合にはユーザーの割込ハンドラに入った時点で SVC
      モードとなっている。

  (1) TA_HLNG の場合

      例外・割込ハンドラは、次の形式となる。

      void inthdr( UINT dintno, void *sp )

      dintno  発生した例外・割込のベクターテーブルのインデックス番号
              なお、デフォルトハンドラの場合、デフォルトハンドラのインデックス
              番号ではなく、発生した例外・割込のインデックス番号となる。

      sp      スタックに保存された以下の情報へのポインタ

                      +---------------+
                sp -> | R12=ip        |
                      | R14=lr        | <- 復帰アドレス
                      | SPSR          |
                      +---------------+

              復帰アドレス
              IRQ の時        割込からの復帰アドレス
              SVC の時        SVC 命令の次の命令への復帰アドレス
              ABT の時        アボートした命令への復帰アドレス
              UND の時        未定義命令の次の命令への復帰アドレス

    ・例外・割込ハンドラに入ったときの CPU の状態は次のようになる。

              CPSR.F = ?      割込・例外発生時の状態のまま
              CPSR.I = 1      割込禁止
              CPSR.A = 1      アボート例外禁止
              CPSR.M = 19     SVC:スーパーバイザーモード

      多重割込は禁止されている。CPSR.I を 0 とすることで、多重割込を許可するこ
      とはできるが、その場合割込コントローラの設定を適切に変更しておく必要があ
      る。

    ・例外・割込ハンドラからの復帰は、関数からの return で行う。

    ・ベクターテーブルには、T-Kernel/OS 内の高級言語対応ルーチンのアドレスが設
      定され、高級言語対応ルーチンから指定されたハンドラを呼び出す。

  (2) TA_ASM の場合

    ・ベクターテーブルへ指定された例外・割込ハンドラのアドレスを直接設定する。
      したがって、T-Kernel/OS を経由せずに直接ハンドラが呼び出される。

    ・T-Kernel/OS を経由しないため、タスク独立部判定のためのフラグが更新されな
      い。そのため、タスク独立部として判定されないので、次のような点に注意が必
      要である。

      ・割込を許可(CPSR.I=0 かつ A=0)すると、タスクディスパッチが発生する可能
        性がある。SVC 命令によるスーパーバイザーコール例外の場合を除き、タスク
        ディスパッチが起きるとその後の動作が異常になる。
      ・システムコールを呼び出した場合、タスク部から呼び出したものとして処理さ
        れる。

      したがって、ハンドラ内でシステムコールを発行する必要がある場合や割込を許
      可する場合には、必要に応じてタスク独立部判定フラグを設定しなければならな
      い。
      また、システムコールを発行するためには SVC モードに切り替えておくことが
      望ましい。(前述のシステムコールの説明を参照)

      タスク独立部判定フラグの設定は、システム共有情報内の taskindp フラグを操
      作することで行う。ただし、割込禁止状態(CPSR.I=1 かつ A=1)で行わなければ
      ならない。また、割込ハンドラを終了する前にフラグを必ず戻さなければならな
      い。

              taskindp++;     /* タスク独立部に入る */

              taskindp--;     /* タスク独立部を出る */

      多重割込の場合などもあるため、taskindp は必ずインクリメント／デクリメン
      トによって設定する必要がある。taskindp = 0 のような設定を行ってはいけな
      い。

    ・例外・割込ハンドラからの復帰は、tk_ret_int() システムコールを使用するか、
      EIT_RETURN マクロ(またはプロセッサモードに応じた INT_RETURN, EXC_RETURN
      のいずれかのマクロ)を使用する。マクロを使用した場合、遅延ディスパッチは
      起こらない。
      なお、マクロを使用する代わりに、独自にマクロに相当する処理を行ってもよい。

    ・tk_ret_int() システムコールは、他のシステムコールとは異なる専用のトラッ
      プにより呼び出す。他のシステムコールのような関数形式の呼び出しはできない。

              SVC     7       // tk_ret_int() 呼び出し (戻らない)

      tk_ret_int() を呼び出す前に、スタックを以下のような状態にしておく必要が
      ある。また、スタックに格納されているレジスタ以外(R0〜R11)は、すべて復帰
      しておく必要がある。
      例外モードは、発生した例外・割込のモード(ハンドラに入ったときのモード)に
      戻しておく必要がある。sp は、発生した例外・割込のモードのスタックポイン
      タ(R13)である。

                      +---------------+
                sp -> | R14_svc       |
                      | R12=ip        |
                      | R14=lr        | <- 復帰アドレス
                      | SPSR          |
                      +---------------+

      上記スタックの R14_svc には、ハンドラに入ったときの SVC モードの R14 レ
      ジスタの値を保存する。その他は、T-Monitor の例外分岐処理ルーチンによって
      保存されたものである。

      例外・割込ハンドラ以外から tk_ret_int() を呼び出した場合の動作は保証され
      ない。

      SVC モードへ切り替えるマクロ ENTER_SVC_MODE と、tk_ret_int() を呼び出す
      マクロ TK_RET_INT が用意されている。

  (3) FIQ 高速割込

      FIQ 高速割込ハンドラは、OS の管理外で実行される。
      FIQ は高速なデータ転送などの用途に使用され、OS のサポートを必要としない
      用途で使用する。

      ・FIQ 高速割込ハンドラとして、TA_HLNG 属性を指定することはできない。
      ・FIQ 高速割込ハンドラの終了に、tk_ret_int() システムコールを呼び出すこ
        とはできない。
      ・FIQ 高速割込ハンドラ内では、すべてのシステムコールおよび拡張 SVC を呼
        び出すことはできない。
      ・FIQ 高速割込ハンドラ内では、IRQ 通常割込およびアボート例外を許可しては
        ならない。

      FIQ 高速割込ハンドラ以外においても、CPSR.F フラグにより FIQ 高速割込を禁
      止する場合には、同時に IRQ 割込およびアボート例外も禁止する必要がある。
      つまり、CPSR.F=1 かつ CPSR.I=1 かつ CPSR.A=1 としなければならず、FIQ を
      禁止している状態で IRQ またはアボート例外のいずれかまたは両方を許可して
      はいけない。また、FIQ 割込の禁止中は、すべてのシステムコールおよび拡張
      SVC を呼び出すことはできない。

      OS においても FIQ を禁止することは避けており、これにより IRQ に比べより
      高速な割込応答が実現されている。高速な割込応答の代償として上記のような制
      限があり、これらが守られない場合 OS が誤動作する可能性がある。

4.6 タスク

      ER tk_cre_tsk( T_CTSK *ctsk )

      typedef struct t_ctsk {
              void    *exinf;         /* 拡張情報 */
              ATR     tskatr;         /* タスク属性 */
              FP      task;           /* タスク起動アドレス */
              PRI     itskpri;        /* タスク起動時優先度 */
              INT     stksz;          /* ユーザスタックサイズ(バイト) */
              INT     sstksz;         /* システムスタックサイズ(バイト) */
              void    *stkptr;        /* ユーザースタックポインタ */
              void    *uatb;          /* タスク固有空間ページテーブル */
              INT     lsid;           /* 論理空間ID */
              ID      resid;          /* リソースID */
      } T_CTSK;

  (1) オプション指定

      tskatr := (TA_ASM ‖ TA_HLNG)
              | [TA_SSTKSZ] | [TA_USERSTACK] | [TA_TASKSPACE] | [TA_RESID]
              | (TA_RNG0 ‖ TA_RNG1 ‖ TA_RNG2 ‖ TA_RNG3)
              | [TA_FPU]

    ・TA_COPn は使用しない。FPU(VFP) には対応していないため、TA_FPU = 0 となる。

    ・lsid は、CONTEXTIDR(CP15.c13.0.c0.1)コンテキストIDレジスタに設定される。
      lsid の有効範囲は 0〜255 となる。
      uatb は、TTBR0(CP15.c2.0.c0.0)変換テーブルベースレジスタ０に設定される。

  (2) タスクの形式

      タスクは次の形式で、TA_HLNG, TA_ASM のどちらを指定しても同じで違いはない。

      void task( INT stacd, void *exinf )

      タスク起動時のレジスタの状態は下記のようになる。

      CPSR.F   = 0    高速割込許可
      CPSR.I   = 0    割込許可
      CPSR.A   = 0    アボート例外許可
      CPSR.T,J = 0,0  ARM モード      タスク起動アドレスの最下位ビットが 0 の
      場合
                 1,0  Thumb モード    タスク起動アドレスの最下位ビットが 1 の
      場合
      CPSR.M   = 16   USR:ユーザーモード              TA_RNG3 指定時
                 31   SYS:システムモード              TA_RNG1〜2 指定時
                 19   SVC:スーパーバイザーモード      TA_RNG0 指定時

      R0 = stacd      タスク起動パラメータ
      R1 = exinf      タスク拡張情報
      R13(sp)         スタックポインタ

      その他のレジスタは不定である。

      タスクの終了は、tk_ext_tsk() または tk_exd_tsk() を用いなければならない。
      単に return してもタスクの終了とはならない。return した場合の動作は保証
      されない。

4.7 タスクのレジスタの設定／参照

      ER tk_set_reg( ID tskid, T_REGS *regs, T_EIT *eit, T_CREGS *cregs )
      ER tk_get_reg( ID tskid, T_REGS *regs, T_EIT *eit, T_CREGS *cregs )

      typedef struct t_regs {
              VW      r[13];          /* 汎用レジスタ R0〜R12 */
              void    *lr;            /* リンクレジスタ R14 */
      } T_REGS;

      typedef struct t_eit {
              void    *pc;            /* プログラムカウンタ R15 */
              UW      cpsr;           /* プログラムステータスレジスタ */
              UW      taskmode;       /* タスクモードフラグ */
      } T_EIT;

      typedef struct t_cregs {
              void    *ssp;           /* システムスタックポインタ R13_svc */
              void    *usp;           /* ユーザースタックポインタ R13_usr */
              void    *uatb;          /* タスク固有空間ページテーブルのアドレ
      ス */
              UW      lsid;           /* タスク論理空間 ID */
      } T_CREGS;

    ・CPSR は、フラグフィールド(J,IT ビットを除く)(ビット31〜27)以外は変更でき
      ない。他のフィールド(ビット26〜0)への設定は無視される。

    ・taskmode は、システム共有情報にあるタスクモードフラグと同じ。メモリーの
      アクセス権情報を保持するレジスタとして扱われる。

    ・DORMANT 状態のタスクに対してレジスタの設定を行ったとき、R0, R1 は
      tk_sta_tsk() によってタスク起動パラメータ／拡張情報が設定されるため、
      tk_set_reg() で設定した値は捨てられることになる。

4.8 タスク例外ハンドラ

      タスク例外ハンドラは、レジスタの保存・復帰を行う専用のエントリールーチン
      を持つ必要がある。エントリールーチンには、マクロ TEXHDR_ENTRY を使用する。
      または、これに相当する処理を独自に行ってもよい。

      タスク例外ハンドラに入るときのスタックの状態

              +---------------+
        sp -> |texcd          | 例外コード
              |PC             | ハンドラからの戻りアドレス
              |CPSR           | ハンドラからの戻り時に復帰する CPSR
              +---------------+

4.9 システムコール・拡張 SVC 呼び出し元情報

      td_hok_svc() によるフックルーチンに渡される、システムコール・拡張 SVC 呼
      び出し元情報の形式は次のようになる。

      typedef struct td_calinf {
              void    *ssp;   /* システムスタックポインタ */
              void    *r11;   /* 呼出時のフレームポインタ */
      } TD_CALINF;

      ssp は T-Monitor の例外分岐ルーチンを抜けた直後のスタック位置を示してお
      り、スタックは次のような内容になっている。

                      +---------------+
               ssp -> |R12=ip         |
                      |R14_svc=lr     | SVC からの戻りアドレス
                      |SPSR           | 呼出元のプロセッサモード
                      +---------------+
                      +---------------+
           R13_xxx -> |R14_xxx=lr     | インターフェースライブラリからの
                      +---------------+                       戻りアドレス

      システムコール・拡張 SVC からの戻り番地は R14_svc である。しかし、通常は
      インターフェースライブラリを利用して呼び出すため、R14_svc はインターフェ
      ースライブラリの番地を指している。

      インターフェースライブラリからの戻り番地は R14_xxx となる。R13_xxx は呼
      出元のプロセッサモードにしたがったスタックポインタであり、呼出元のプロセ
      ッサモードは SPSR で知ることができる。呼出元のプロセッサモードが SVC の
      場合、ssp + 12 が R13_xxx に相当する。
      なお、標準のインターフェースライブラリを使用していない場合は、この限りで
      はない。

4.10 CPU 割込制御

      以下の CPU 割込制御マクロ関数は、CPSR.I および A フラグを禁止・許可する。
      CPSR.F フラグは変更しない。つまり、IRQ 通常割込とアボート例外の割込制御
      であり、FIQ 高速割込には影響しない。

      DI( UINT intsts )       IRQ 割込禁止
      EI( UINT intsts )       IRQ 割込許可(以前の状態へ復帰)

4.11 割込コントローラ

      割込コントローラの操作に関しては下記のライブラリ関数がある。

  (1) 割込ベクター(INTVEC)の値

      #define IV_IRQ(n)       (  32 + (n) )   /* IRQ 割込     0〜95 */
      #define IV_GPIO(n)      ( 128 + (n) )   /* GPIO 割込    0〜127 */

      割込コントローラの操作関数で intvec として指定可能な値は、これら IRQ,
      GPIO の各割込の範囲である。
      有効範囲外を指定した場合の動作は保証されない。

  (2) 割込モード設定

      void SetIntMode( INTVEC intvec, UINT mode )

      intvec で指定した割込を mode で指定したモードに設定する。
      不正な mode を指定した場合の動作は保証されない。

      #define IM_ENA          0x0001  /* 割込線有効 */
      #define IM_DIS          0x0000  /* 割込線無効 */
      #define IM_INV          0x0002  /* 極性反転 */
      #define IM_LEVEL        0x0200  /* レベル */
      #define IM_EDGE         0x0000  /* エッジ */
      #define IM_HI           0x0000  /* ハイレベル／立ち上がりエッジ */
      #define IM_LOW          0x0100  /* ローレベル／立ち下がりエッジ */
      #define IM_BOTH         0x0400  /* 両エッジ */
      #define IM_ASYN         0x0800  /* 非同期 */

      IRQ の場合
      mode := IM_ENA | IM_INV
       または IM_DIS

      GPIO の場合
      mode := IM_ENA | IM_LEVEL | (IM_HI ‖ IM_LOW) | IM_ASYN
       または IM_ENA | IM_EDGE | (IM_HI ‖ IM_LOW ‖ IM_BOTH) | IM_ASYN
       または IM_DIS

      IM_ENA が指定されると、指定されたモード設定を行った後、割込禁止
      (DisableInt)に設定した上で、割込線を有効にする。
      IM_DIS が指定されると割込線を無効にする。無効になった割込線は、割込許可
      (EnableInt)しても割込は発生しない。
      初期状態では、割込線無効(IM_DIS)である。

      なお、下記の GPIO 割込に対応する割込コントローラ側の設定は、システム起動
      時に IM_ENA に設定され、割込許可(EnableInt)状態となっている。

              IRQ26   GIO6 Interrupt (GPIO port  96〜111)
              IRQ27   GIO7 Interrupt (GPIO port 112〜127)
              IRQ50   GIO0 Interrupt (GPIO port   0〜 15)
              IRQ51   GIO1 Interrupt (GPIO port  16〜 31)
              IRQ52   GIO2 Interrupt (GPIO port  32〜 47)
              IRQ53   GIO3 Interrupt (GPIO port  48〜 63)
              IRQ79   GIO4 Interrupt (GPIO port  64〜 79)
              IRQ80   GIO5 Interrupt (GPIO port  80〜 95)

  (3) 割込許可

      void EnableInt( INTVEC intvec )

      intvec で指定した割込を許可する。

  (4) 割込禁止

      void DisableInt( INTVEC intvec )

      intvec で指定した割込を禁止する。

  (5) 割込要求のクリア

      void ClearInt( INTVEC intvec )

      intvec の割込要求をクリアする。

      エッジトリガーの割込のみクリアする必要がある。

  (6) 割込要求の有無の確認

      BOOL CheckInt( INTVEC intvec )

      intvec の割込要求があるか調べる。
      割込要求があれば TRUE (0 以外) を返す。

      割込要求の有無は、raw ステータスレジスタにより検査する。

4.12 その他

  (1) 周辺デバイス領域に対するI/Oポートアクセス

      周辺デバイス領域に対するメモリータイプのモード設定を Device としている。
      そのため、周辺デバイス領域に対して out_b(), out_h(), out_w(), out_d() を
      実行した場合でも、これらのAPIの処理はドレイン(データの書き出し)の完了を
      待たずに終了する。(周辺デバイス領域については「2.3 メモリーマップ」を参照)

5. デバイスドライバ実装仕様

5.1 システムディスクドライバ

  (1) 操作対象となるデバイス

      以下のシステムディスクを対象とする。

              - microSD カードスロットに挿入した microSD カード
              - ROM ディスク (NOR Flash)

              デバイス名      デバイス
              pcb             microSD カード
              rda             ROM ディスク (NOR Flash)

      サブユニットは以下のデバイスでのみサポートする。

              microSD カード
              ※サブユニットは最大 4 個

      microSD カードへのアクセスは、EM1-D512 の以下のリソースを使用する。

              メディア     コントローラ       カード検出用 GPIO
              microSD      SDIA(SD0)          GPIO P3

      SDIA の各種割込 (SDIx_SD_INT, SDIx_CC_INT) は使用しない。
      SDIA, GPIO を使用するために必要な I/O ピンの設定およびクロックの設定は、
      適切に行われていることを前提とする。

      FlashROM (NOR) を使用した ROM ディスクは、RomInfo に定義した領域をディス
      クとして使用する。

  (2) 機種依存事項 (システムディスクドライバ)

   (a) DEVCONF エントリ

      システムディスクドライバは、以下の DEVCONF エントリを参照する。

      HdSpec  HD 仕様
              xxNI xxxx xxxx xxxx xxxx
              [デフォルト: 0x00010000]

              I : イジェクト可能ディスクのメディア挿入自動チェック
              N : イジェクト可能ディスクのメディア自動イジェクト禁止

      HdChkPeriod 周期 (msec)
              イジェクト可能ディスクのチェック周期
              [デフォルト: 3000]

   (b) マスターブートレコードのアクセス機能

      サブユニットに対応したデバイスに対し、マスターブートレコードのアクセスの
      ための特殊機能が用意されている (物理ユニットのみ)。

      属性レコード番号:       -999999 (R)

      data:   UW              magic;
              DiskBlock0      mboot;

      magic = CH4toW('M','B','R','R') : マスターブートレコードの読み込み
              CH4toW('M','B','R','W') : マスターブートレコードの書き込み (読み
                                        込み処理で書き込む)

      ※ CH4toW(c1, c2, c3, c4) は、( ((c4)<<24)|((c3)<<16)|((c2)<<8)|(c1) )。

      ☆ マスターブートレコードの書き込みにより、使用中の区画が変更された場合
         の動作は保証しない。

   (c) 区画 (サブユニット) の扱い

      サブユニットに対応したデバイスに対しては、区画情報の動的変更に対応するた
      め、常に 4 つの区画 (サブユニット) が登録される。なお、空の区画に対して
      オープンした場合は、E_NOMDA のエラーとなる。

   (d) CHS 情報の算出方法

      一般に、CHS から計算した全体容量は本来のディスク全体の容量より小さくなる。

      シリンダ (C)    最大 1023
      ヘッド (H)      最大 255
      セクタ (S)      最大 63

      ・C は最大 1024 であるが、通常は最終シリンダは使用しない。
      ・H は最大 256 であるが、通常は 255 としている。

      CHS 情報は以下のように決定している。

      1.物理 CHS 情報から、上記制限に入るような CHS 情報を以下の方式で計算する
        (pC, pH, pS : 物理 CHS 情報)。
              T = pC * pH * pS; C = pC; H = pH; S = pS;
              while (C > 1024) {C >>= 1; H <<= 1;}
              if (S > 63) S = 63;
              if (H > 255) H = 255;
              C = T / H / S;
              if (C > 1023) C = 1023;

      2.区画が設定済みのときは、区画情報から CHS 情報を計算する。
              S = 区画の終了セクタ;
              H = 区画の終了ヘッド + 1;
              C = T / H / S - 1;

5.2 時計 (クロック) ドライバ

  (1) 操作対象となるデバイス

      EM1-D512 の SPI(SP0) およびこれに接続された RTC(RX-4581NB) を対象とする。
      SP0 には RTC の他、Audio CODEC(ML7037), 電源管理コントローラ (DA9052) も
      接続されているため、SPI 操作用のインタフェースも併せて提供する。

      デバイス名は "CLOCK" とする。

  (2) ハードウェアの制限事項

      不揮発レジスタ (フリーレジスタ) への対応は行わない。
      RTC 割り込みには対応しない。

   (a) DN_CKAUTOPWON:      自動電源オン時刻の設定 / 取得 (RW)

      対応しない。エラー (E_NOSPT) とする。

   (b) DN_CKREGISTER:      不揮発レジスターの書き込み / 読み出し (RW)

      対応しない。エラー (E_NOSPT) とする。

      DN_CKAUTOPWON に対応しないため、事象通知も行わない。

  (3) SPI(SP0) 操作用インタフェース

      SPI(SP0) に接続された RTC, Audio CODEC, 電源管理コントローラの操作は、以
      下のインタフェースを使用して行う。

      <device/em1d512/em1d512_iic.h>
      ER      em1d512_spixfer(W cs, UB *xmit, UB *recv, W len)

      SPI(SP0) に接続されたデバイスに対し、データの送受信を行う。

              cs:     通信対象デバイス
                      0       電源管理コントローラ (DA9052)
                      1       Audio CODEC (ML7037)
                      2       RTC (RX-4581NB)

              xmit:   送信データを格納する領域の先頭ポインタ
              recv:   受信データを格納する領域の先頭ポインタ
              len:    送信/受信データ数 (byte)

              戻り値: E_OK もしくはエラー (E_IO, E_TMOUT, E_PAR)

      SP0 割り込みを使用して動作するため、割り込みハンドラ内、もしくは割り込み
      が禁止された状態から呼び出してはならない。SP0 割り込み待ちは、tk_slp_tsk
      () を使用する。

5.3 スクリーン (ディスプレイドライバ)

  (1) 操作対象となるデバイス

      EM1-D512 に内蔵される、LCD コントローラを使用する。MEMC-LCD DirectPath
      モードを使用し、IMC (イメージコンポーザ) 無しで動作させる。
      LCD コントローラに加え、LCD の点灯制御に GPIO P82 および DA9052 の White
      LED Driver を使用する。
      LCD を使用するために必要な I/O ピンの設定は、適切に行われていることを前
      提とする。表示に使用するピクセルクロックは、スクリーンドライバが PLL2 を
      操作して生成する。

  (2) 機種依存事項 (スクリーンドライバ)

      スクリーンドライバで使用可能な属性データには、制限がある。

   (a) DN_SCRNO:           使用する表示モードの取り出し / 設定 (RW)

      表示モードの取り出し (R) のみ対応する。

   (b) DN_SCRUPDFN:        スクリーンの更新関数の取り出し (R)

      対応しない。
      関数ポインタには NULL がセットされる。

   (c) DN_SCRVFREQ:        モニタの垂直周波数の設定 / 取り出し (RW)

      対応しない。
      取り出し:       vfreq には 0 がセットされる。
      設定:           vfreq の値を無視する。

   (d) DN_SCRBRIGHT:       スクリーンの明るさの設定 / 取り出し (RW)

   (e) DN_SCRUPDRECT:      スクリーン表示の更新 (W)

   (f) DN_SCRADJUST:       モニタのタイミング調整の設定 / 取り出し (RW)

   (g) DN_SCRMEMCLK:       Video-RAM のクロック設定 / 取り出し (RW)

   (h) DN_SCRWRITE:        直接スクリーン表示 (W)

      非対応。エラー (E_NOSPT) を返す。

   (i) サポートしている表示モード

      以下の表示モードにのみ対応する。

              800×480, 16bpp 固定

   (j) 表示モードの設定

      表示モードの設定はシステム起動時にのみ行っているため、属性データとして動
      的に設定する機能はサポートしていない。

   (k) 垂直周波数（リフレッシュレート）の設定

      垂直周波数の設定機能はサポートしない。

   (l) DEVCONF エントリ

      スクリーンドライバが参照する DEVCONF エントリは、以下の通り。

      VIDEOMODE       mode

      このエントリは予約する（使用してはならない）。

      VIDEOATTR       attr

      このエントリは予約する（使用してはならない）。

5.4 KB/PD ドライバ

  (1) 操作対象となるデバイス

              - キーパッド
              - タッチパネル

      キーパッドは、GPIO P4(SW4), P6(SW3), P7(SW2) を使用し、キーの ON/OFF は
      これらの GPIO 割り込みを使用して検知する。
      タッチパネルの A/D 変換値は、RTC ドライバが提供する SPI(SP0) 操作用イン
      タフェースを使用して、電源管理コントローラ (DA9052) から得る。DA9052 の
      割り込みマスクレジスタには以下の値を設定し、PEN_DOWN 割り込みのみを発生
      させるようにする。DA9052 からの割り込みは、GPIO P0 割り込みとして通知さ
      れる。

              R10(IRQ_MASK_A) 0xff
              R11(IRQ_MASK_B) 0xbf
              R12(IRQ_MASK_C) 0xff
              R13(IRQ_MASK_D) 0xff

  (2) 機種依存事項 (KB/PDドライバ)

   (a) DEVCONFエントリ

      実IOドライバ(lowkbpd)は、以下のDEVCONFエントリを参照する。

      TEngTabletPar   X-bias X-span Y-bias Y-span PointerNoDisp ScanRate(off)
                      ScanRate(on)
              X-bias, X-span, Y-bias, Y-spanは、タッチパッドから得られた座標デ
              ータを正規化する際に使用する補正用パラメータである。
              PointerNoDispに1を指定した場合、ポインタの表示を行わない (MetaBut.
              nodsp=1 を渡す)。
              ScanRate(off)は、ペンをリリース後、次のペンタッチ検出を行うまで
              の時間をミリ秒単位で指定する。
              ScanRate(on)は、ペンタッチ中のポーリング間隔をミリ秒単位で指定す
              る。

              デフォルトは、PointerNoDisp=0, ScanRate(off)=50, ScanRate(on)=50,
              X-bias/X-span/Y-bias/Y-spanはLCDパネルに対応した値とする。

      TEngUseTablet   タッチパネルの使用可否
              1を指定した場合はタッチパネルを使用する。
              0を使用した場合はタッチパネルを使用しない。

              デフォルトは1とする。

   (b) 押しボタンスイッチに関する事項

      押しボタンスイッチとスキャンコードの対応は、以下の通りとする。

              SW2     SW3     SW4
              ------------------------
              0x6e    0x6d    0x6f

5.5 RS-232C ドライバ

  (1) 操作対象となるデバイス

      EM1-D512 に内蔵される、UART0〜2 を対象とする。
      これらの UART を使用するために必要な I/O ピンの設定およびクロックの設定
      は、適切に行われていることを前提とする。

      RS-232C のデバイス名・対応するポート・使用するリソースを、以下に示す。

              ポート名        アドレス                割り込み
              "rsa" (UART0)   0x50000000〜0x5000ffff  IV_IRQ(9)
              "rsb" (UART1)   0x50010000〜0x5001ffff  IV_IRQ(10)
              "rsc" (UART2)   0x50020000〜0x5002ffff  IV_IRQ(11)

      チップから以下の信号線が出力されないため、これらの信号線に関連する機能は
      使用できない (使用しないこと)。

              UART0   RI, DSR, DTR, RTS, CTS
              UART1   RI, DSR, DTR, RTS, CTS
              UART2   RI, DSR, DTR

  (2) 機種依存事項 (RSドライバ)

   (a) 各種属性データ

      RS ドライバで設定可能な属性データ、および属性データに設定可能な各種パラ
      メータの範囲を、以下に示す。

   (b) DN_RSMODE:  通信モード (RW)

      以下のモードに対応する。

              parity:         0:無し, 1:奇数, 2:偶数
              datalen:        0:5bit, 1:6bit, 2:7bit, 3:8bit
              stopbits:       0:1bit, 1:1.5bit, 2:2bit
              baud:           300〜115200

   (c) DN_RSFLOW:  フロー制御 (RW)

      UART0, UART1 については、csflow および rsflow に 0 を指定すること。

   (d) DN_RSSTAT:  回線状態 (R)

      一部の信号線が利用できないため、以下の値は意味を持たない。

              UART0   CI(RI), CD(DCD), DR(DSR), CS(CTS)
              UART1   CI(RI), CD(DCD), DR(DSR), CS(CTS)
              UART2   CI(RI), CD(DCD), DR(DSR)

  (3) 機種依存事項 (シリアル I/O ドライバ)

   (a) ポート番号とデバイスとの対応

      シリアル I/O ドライバの serial_in(), serial_out(), serial_ctl()で指定す
      るport番号と、対応するデバイスは、以下の通りである。

              port    デバイス
              0       UART0
              1       UART1
              2       UART2
              3       予約

   (b) serial_ctl()の制限事項

      ER  serial_ctl(W port, W kind, UW *arg) の kind, arg の指定には、制限が
      ある。

      <kind>          <arg>
        DN_RSFLOW     RsFlow          フロー制御

              ・RsFlow の設定は、RS ドライバの DN_RSFLOW の項を参照。

      - DN_RSSTAT     RsStat          回線状態の取得

              ・取得した RsStat の内容は、RS ドライバの DN_RSSTAT の項を参照。

        RS_LINECTL    UW              制御線の ON/OFF 設定

              ・以下の指定による信号線の操作は、意味を為さない。

                      UART0   RSCTL_DTR, RSCTL_RTS
                      UART1   RSCTL_DTR, RSCTL_RTS
                      UART2   RSCTL_DTR

以上
